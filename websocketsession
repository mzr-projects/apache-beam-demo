Ah, you're using the lower-level WebSocket API with `WebSocketSession` instead of Spring's STOMP messaging! Here's how to validate JSON data in that scenario:

## 1. **Basic WebSocket Handler with Validation**

```java
@Component
public class MyWebSocketHandler extends TextWebSocketHandler {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    private final Validator validator;
    
    public MyWebSocketHandler() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        this.validator = factory.getValidator();
    }
    
    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String payload = message.getPayload();
        
        try {
            // Step 1: Parse JSON
            MessageDTO messageDTO = objectMapper.readValue(payload, MessageDTO.class);
            
            // Step 2: Validate
            Set<ConstraintViolation<MessageDTO>> violations = validator.validate(messageDTO);
            
            if (!violations.isEmpty()) {
                sendErrorResponse(session, buildValidationErrorMessage(violations));
                return;
            }
            
            // Step 3: Process valid message
            processValidMessage(session, messageDTO);
            
        } catch (JsonProcessingException e) {
            sendErrorResponse(session, "Invalid JSON format: " + e.getMessage());
        } catch (Exception e) {
            sendErrorResponse(session, "Processing error: " + e.getMessage());
        }
    }
    
    private String buildValidationErrorMessage(Set<ConstraintViolation<MessageDTO>> violations) {
        return violations.stream()
            .map(v -> v.getPropertyPath() + ": " + v.getMessage())
            .collect(Collectors.joining(", "));
    }
    
    private void sendErrorResponse(WebSocketSession session, String error) throws IOException {
        ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", error);
        session.sendMessage(new TextMessage(objectMapper.writeValueAsString(errorResponse)));
    }
    
    private void processValidMessage(WebSocketSession session, MessageDTO message) throws IOException {
        // Your business logic here
        SuccessResponse response = new SuccessResponse("Message received", message.getId());
        session.sendMessage(new TextMessage(objectMapper.writeValueAsString(response)));
    }
}
```

## 2. **Enhanced Validation with Custom Validator Service**

```java
@Service
public class WebSocketValidationService {
    
    private final Validator validator;
    private final ObjectMapper objectMapper;
    
    public WebSocketValidationService() {
        this.validator = Validation.buildDefaultValidatorFactory().getValidator();
        this.objectMapper = new ObjectMapper();
        this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);
    }
    
    public <T> ValidationResult<T> validateJson(String json, Class<T> clazz) {
        try {
            // Parse JSON
            T object = objectMapper.readValue(json, clazz);
            
            // Validate object
            Set<ConstraintViolation<T>> violations = validator.validate(object);
            
            if (violations.isEmpty()) {
                return ValidationResult.success(object);
            } else {
                List<String> errors = violations.stream()
                    .map(v -> String.format("Field '%s': %s", v.getPropertyPath(), v.getMessage()))
                    .collect(Collectors.toList());
                return ValidationResult.failure(errors);
            }
            
        } catch (JsonProcessingException e) {
            return ValidationResult.failure(Collections.singletonList("Invalid JSON: " + e.getMessage()));
        }
    }
    
    @Data
    public static class ValidationResult<T> {
        private final boolean valid;
        private final T data;
        private final List<String> errors;
        
        public static <T> ValidationResult<T> success(T data) {
            return new ValidationResult<>(true, data, null);
        }
        
        public static <T> ValidationResult<T> failure(List<String> errors) {
            return new ValidationResult<>(false, null, errors);
        }
    }
}
```

## 3. **WebSocket Handler Using Validation Service**

```java
@Component
public class EnhancedWebSocketHandler extends TextWebSocketHandler {
    
    @Autowired
    private WebSocketValidationService validationService;
    
    @Autowired
    private MessageService messageService;
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String payload = message.getPayload();
        
        // Determine message type based on a type field or structure
        MessageType messageType = determineMessageType(payload);
        
        switch (messageType) {
            case CREATE_MESSAGE:
                handleCreateMessage(session, payload);
                break;
            case UPDATE_MESSAGE:
                handleUpdateMessage(session, payload);
                break;
            default:
                sendError(session, "Unknown message type");
        }
    }
    
    private void handleCreateMessage(WebSocketSession session, String payload) throws IOException {
        ValidationResult<CreateMessageDTO> result = 
            validationService.validateJson(payload, CreateMessageDTO.class);
        
        if (!result.isValid()) {
            sendValidationError(session, result.getErrors());
            return;
        }
        
        // Additional business validation
        CreateMessageDTO dto = result.getData();
        if (!isAuthorized(session, dto)) {
            sendError(session, "Not authorized for this operation");
            return;
        }
        
        // Process valid message
        messageService.createMessage(dto);
        sendSuccess(session, "Message created successfully");
    }
    
    private void sendValidationError(WebSocketSession session, List<String> errors) throws IOException {
        Map<String, Object> response = new HashMap<>();
        response.put("type", "VALIDATION_ERROR");
        response.put("errors", errors);
        response.put("timestamp", System.currentTimeMillis());
        
        session.sendMessage(new TextMessage(objectMapper.writeValueAsString(response)));
    }
}
```

## 4. **JSON Schema Validation Approach**

```java
@Component
public class JsonSchemaWebSocketHandler extends TextWebSocketHandler {
    
    private final JsonSchema messageSchema;
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    public JsonSchemaWebSocketHandler() {
        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);
        this.messageSchema = factory.getSchema(
            getClass().getResourceAsStream("/schemas/message-schema.json")
        );
    }
    
    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String payload = message.getPayload();
        
        try {
            // Parse to JsonNode for schema validation
            JsonNode jsonNode = objectMapper.readTree(payload);
            
            // Validate against schema
            Set<ValidationMessage> schemaErrors = messageSchema.validate(jsonNode);
            
            if (!schemaErrors.isEmpty()) {
                sendSchemaValidationError(session, schemaErrors);
                return;
            }
            
            // Convert to DTO for additional validation
            MessageDTO dto = objectMapper.treeToValue(jsonNode, MessageDTO.class);
            
            // Custom business validation
            List<String> businessErrors = validateBusinessRules(dto);
            if (!businessErrors.isEmpty()) {
                sendBusinessValidationError(session, businessErrors);
                return;
            }
            
            // Process valid message
            processMessage(session, dto);
            
        } catch (JsonProcessingException e) {
            sendError(session, "JSON_PARSE_ERROR", "Invalid JSON format");
        }
    }
    
    private List<String> validateBusinessRules(MessageDTO dto) {
        List<String> errors = new ArrayList<>();
        
        // Custom business logic
        if (dto.getPriority() > 5 && dto.getType() != MessageType.URGENT) {
            errors.add("High priority requires URGENT type");
        }
        
        if (dto.getScheduledTime() != null && dto.getScheduledTime().isBefore(LocalDateTime.now())) {
            errors.add("Scheduled time cannot be in the past");
        }
        
        return errors;
    }
}
```

## 5. **Interceptor Pattern for Validation**

```java
@Component
public class ValidationInterceptor {
    
    private final List<MessageValidator> validators = new ArrayList<>();
    
    @PostConstruct
    public void init() {
        validators.add(new StructuralValidator());
        validators.add(new SecurityValidator());
        validators.add(new BusinessRuleValidator());
    }
    
    public ValidationResult validate(String message, WebSocketSession session) {
        for (MessageValidator validator : validators) {
            ValidationResult result = validator.validate(message, session);
            if (!result.isValid()) {
                return result;
            }
        }
        return ValidationResult.valid();
    }
}

interface MessageValidator {
    ValidationResult validate(String message, WebSocketSession session);
}

class StructuralValidator implements MessageValidator {
    private final ObjectMapper mapper = new ObjectMapper();
    
    @Override
    public ValidationResult validate(String message, WebSocketSession session) {
        try {
            JsonNode node = mapper.readTree(message);
            if (!node.has("type") || !node.has("data")) {
                return ValidationResult.invalid("Missing required fields: type, data");
            }
            return ValidationResult.valid();
        } catch (Exception e) {
            return ValidationResult.invalid("Invalid JSON structure");
        }
    }
}

class SecurityValidator implements MessageValidator {
    @Override
    public ValidationResult validate(String message, WebSocketSession session) {
        // Check for XSS, injection attacks, etc.
        if (message.contains("<script>") || message.contains("javascript:")) {
            return ValidationResult.invalid("Potential security threat detected");
        }
        
        // Check message size
        if (message.length() > 10000) { // 10KB limit
            return ValidationResult.invalid("Message size exceeds limit");
        }
        
        return ValidationResult.valid();
    }
}
```

## 6. **Complete Example with Error Handling**

```java
@Component
@Slf4j
public class ProductionWebSocketHandler extends TextWebSocketHandler {
    
    @Autowired
    private WebSocketValidationService validationService;
    
    private final ObjectMapper objectMapper;
    private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    
    public ProductionWebSocketHandler() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        sessions.put(session.getId(), session);
        log.info("WebSocket connection established: {}", session.getId());
    }
    
    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String payload = message.getPayload();
        
        // Log incoming message
        log.debug("Received message from session {}: {}", session.getId(), payload);
        
        try {
            // First level: Check if it's valid JSON
            if (!isValidJson(payload)) {
                sendError(session, "INVALID_JSON", "Message must be valid JSON");
                return;
            }
            
            // Second level: Validate against DTO
            BaseMessage baseMessage = objectMapper.readValue(payload, BaseMessage.class);
            
            // Route based on message type
            switch (baseMessage.getType()) {
                case "CREATE":
                    handleCreate(session, payload);
                    break;
                case "UPDATE":
                    handleUpdate(session, payload);
                    break;
                case "DELETE":
                    handleDelete(session, payload);
                    break;
                default:
                    sendError(session, "UNKNOWN_TYPE", "Unknown message type: " + baseMessage.getType());
            }
            
        } catch (Exception e) {
            log.error("Error processing message", e);
            sendError(session, "PROCESSING_ERROR", "Failed to process message");
        }
    }
    
    private void handleCreate(WebSocketSession session, String payload) throws IOException {
        ValidationResult<CreateDTO> result = validationService.validateJson(payload, CreateDTO.class);
        
        if (!result.isValid()) {
            sendValidationErrors(session, result.getErrors());
            return;
        }
        
        CreateDTO dto = result.getData();
        
        // Additional validation
        if (isDuplicate(dto.getId())) {
            sendError(session, "DUPLICATE_ID", "Resource with this ID already exists");
            return;
        }
        
        // Process the create request
        String responseId = processCreate(dto);
        sendSuccess(session, "CREATE_SUCCESS", responseId);
    }
    
    private boolean isValidJson(String json) {
        try {
            objectMapper.readTree(json);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    private void sendValidationErrors(WebSocketSession session, List<String> errors) throws IOException {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "ERROR");
        response.put("code", "VALIDATION_FAILED");
        response.put("errors", errors);
        response.put("timestamp", Instant.now());
        
        session.sendMessage(new TextMessage(objectMapper.writeValueAsString(response)));
    }
    
    private void sendError(WebSocketSession session, String code, String message) throws IOException {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "ERROR");
        response.put("code", code);
        response.put("message", message);
        response.put("timestamp", Instant.now());
        
        session.sendMessage(new TextMessage(objectMapper.writeValueAsString(response)));
    }
    
    private void sendSuccess(WebSocketSession session, String code, Object data) throws IOException {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "SUCCESS");
        response.put("code", code);
        response.put("data", data);
        response.put("timestamp", Instant.now());
        
        session.sendMessage(new TextMessage(objectMapper.writeValueAsString(response)));
    }
    
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        log.error("Transport error for session {}", session.getId(), exception);
        sessions.remove(session.getId());
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        sessions.remove(session.getId());
        log.info("WebSocket connection closed: {} with status: {}", session.getId(), status);
    }
}
```

## Key Best Practices:

1. **Validate Early**: Check JSON format before attempting to deserialize
2. **Layer Validation**: Structure → Security → Business Rules
3. **Clear Error Messages**: Provide specific error codes and descriptions
4. **Logging**: Log validation failures for monitoring
5. **Session Management**: Track sessions for targeted error responses
6. **Graceful Degradation**: Handle errors without closing the connection
7. **Performance**: Consider caching validators and schemas
8. **Security**: Sanitize input and check for injection attacks

This approach gives you full control over the validation process while working directly with `WebSocketSession` and raw text messages.

