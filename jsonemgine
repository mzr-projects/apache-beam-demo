import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

// 1. Query condition representation
public class QueryCondition {
    private String field;
    private String operator;
    private Object value;
    private String logicalOperator; // AND, OR
    
    public QueryCondition() {}
    
    public QueryCondition(String field, String operator, Object value) {
        this.field = field;
        this.operator = operator;
        this.value = value;
    }
    
    // Getters and setters
    public String getField() { return field; }
    public void setField(String field) { this.field = field; }
    
    public String getOperator() { return operator; }
    public void setOperator(String operator) { this.operator = operator; }
    
    public Object getValue() { return value; }
    public void setValue(Object value) { this.value = value; }
    
    public String getLogicalOperator() { return logicalOperator; }
    public void setLogicalOperator(String logicalOperator) { this.logicalOperator = logicalOperator; }
}

// 2. Query request structure
public class JsonQueryRequest {
    private List<QueryCondition> conditions;
    private List<String> selectFields;
    private String sortBy;
    private String sortDirection;
    private Integer limit;
    private Integer offset;
    
    public JsonQueryRequest() {
        this.conditions = new ArrayList<>();
        this.selectFields = new ArrayList<>();
    }
    
    // Getters and setters
    public List<QueryCondition> getConditions() { return conditions; }
    public void setConditions(List<QueryCondition> conditions) { this.conditions = conditions; }
    
    public List<String> getSelectFields() { return selectFields; }
    public void setSelectFields(List<String> selectFields) { this.selectFields = selectFields; }
    
    public String getSortBy() { return sortBy; }
    public void setSortBy(String sortBy) { this.sortBy = sortBy; }
    
    public String getSortDirection() { return sortDirection; }
    public void setSortDirection(String sortDirection) { this.sortDirection = sortDirection; }
    
    public Integer getLimit() { return limit; }
    public void setLimit(Integer limit) { this.limit = limit; }
    
    public Integer getOffset() { return offset; }
    public void setOffset(Integer offset) { this.offset = offset; }
}

// 3. JSON Query Engine
public class JsonQueryEngine {
    private final ObjectMapper objectMapper;
    
    public JsonQueryEngine() {
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * Execute query on a list of JSON objects
     */
    public List<JsonNode> executeQuery(List<JsonNode> jsonData, JsonQueryRequest request) {
        return jsonData.stream()
            .filter(json -> matchesConditions(json, request.getConditions()))
            .sorted((a, b) -> compareNodes(a, b, request.getSortBy(), request.getSortDirection()))
            .skip(request.getOffset() != null ? request.getOffset() : 0)
            .limit(request.getLimit() != null ? request.getLimit() : Long.MAX_VALUE)
            .map(json -> projectFields(json, request.getSelectFields()))
            .collect(Collectors.toList());
    }
    
    /**
     * Execute query on JSON array string
     */
    public String executeQuery(String jsonArrayString, String queryString) throws Exception {
        JsonNode jsonArray = objectMapper.readTree(jsonArrayString);
        JsonQueryRequest request = objectMapper.readValue(queryString, JsonQueryRequest.class);
        
        if (!jsonArray.isArray()) {
            throw new IllegalArgumentException("Input must be a JSON array");
        }
        
        List<JsonNode> dataList = new ArrayList<>();
        jsonArray.forEach(dataList::add);
        
        List<JsonNode> results = executeQuery(dataList, request);
        return objectMapper.writeValueAsString(results);
    }
    
    /**
     * Check if a JSON object matches all conditions
     */
    private boolean matchesConditions(JsonNode json, List<QueryCondition> conditions) {
        if (conditions.isEmpty()) return true;
        
        boolean result = true;
        String currentLogicalOp = "AND";
        
        for (int i = 0; i < conditions.size(); i++) {
            QueryCondition condition = conditions.get(i);
            boolean conditionResult = evaluateCondition(json, condition);
            
            if (i == 0) {
                result = conditionResult;
            } else {
                if ("OR".equalsIgnoreCase(currentLogicalOp)) {
                    result = result || conditionResult;
                } else { // AND
                    result = result && conditionResult;
                }
            }
            
            // Set logical operator for next iteration
            if (condition.getLogicalOperator() != null) {
                currentLogicalOp = condition.getLogicalOperator();
            }
        }
        
        return result;
    }
    
    /**
     * Evaluate a single condition against a JSON object
     */
    private boolean evaluateCondition(JsonNode json, QueryCondition condition) {
        JsonNode fieldValue = getFieldValue(json, condition.getField());
        Object expectedValue = condition.getValue();
        String operator = condition.getOperator().toLowerCase();
        
        switch (operator) {
            case "eq":
                return isEqual(fieldValue, expectedValue);
            case "ne":
                return !isEqual(fieldValue, expectedValue);
            case "gt":
                return isGreaterThan(fieldValue, expectedValue);
            case "gte":
                return isGreaterThanOrEqual(fieldValue, expectedValue);
            case "lt":
                return isLessThan(fieldValue, expectedValue);
            case "lte":
                return isLessThanOrEqual(fieldValue, expectedValue);
            case "like":
            case "contains":
                return containsText(fieldValue, expectedValue);
            case "starts_with":
                return startsWithText(fieldValue, expectedValue);
            case "ends_with":
                return endsWithText(fieldValue, expectedValue);
            case "in":
                return isInList(fieldValue, expectedValue);
            case "not_in":
                return !isInList(fieldValue, expectedValue);
            case "is_null":
                return fieldValue == null || fieldValue.isNull();
            case "is_not_null":
                return fieldValue != null && !fieldValue.isNull();
            case "regex":
                return matchesRegex(fieldValue, expectedValue);
            case "exists":
                return fieldValue != null;
            case "not_exists":
                return fieldValue == null;
            default:
                throw new IllegalArgumentException("Unsupported operator: " + operator);
        }
    }
    
    /**
     * Get field value from JSON, supporting nested fields with dot notation
     */
    private JsonNode getFieldValue(JsonNode json, String fieldPath) {
        if (fieldPath == null || fieldPath.isEmpty()) return null;
        
        String[] parts = fieldPath.split("\\.");
        JsonNode current = json;
        
        for (String part : parts) {
            if (current == null || current.isNull()) return null;
            
            // Handle array index access like "items[0]"
            if (part.contains("[") && part.contains("]")) {
                String arrayField = part.substring(0, part.indexOf("["));
                String indexStr = part.substring(part.indexOf("[") + 1, part.indexOf("]"));
                
                current = current.get(arrayField);
                if (current != null && current.isArray()) {
                    try {
                        int index = Integer.parseInt(indexStr);
                        current = current.get(index);
                    } catch (NumberFormatException e) {
                        return null;
                    }
                }
            } else {
                current = current.get(part);
            }
        }
        
        return current;
    }
    
    // Comparison methods
    private boolean isEqual(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) {
            return expectedValue == null;
        }
        
        if (fieldValue.isTextual()) {
            return fieldValue.asText().equals(String.valueOf(expectedValue));
        } else if (fieldValue.isNumber()) {
            return fieldValue.asDouble() == Double.parseDouble(String.valueOf(expectedValue));
        } else if (fieldValue.isBoolean()) {
            return fieldValue.asBoolean() == Boolean.parseBoolean(String.valueOf(expectedValue));
        }
        
        return fieldValue.toString().equals(String.valueOf(expectedValue));
    }
    
    private boolean isGreaterThan(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        if (fieldValue.isNumber()) {
            return fieldValue.asDouble() > Double.parseDouble(String.valueOf(expectedValue));
        } else if (fieldValue.isTextual()) {
            return fieldValue.asText().compareTo(String.valueOf(expectedValue)) > 0;
        }
        
        return false;
    }
    
    private boolean isGreaterThanOrEqual(JsonNode fieldValue, Object expectedValue) {
        return isGreaterThan(fieldValue, expectedValue) || isEqual(fieldValue, expectedValue);
    }
    
    private boolean isLessThan(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        if (fieldValue.isNumber()) {
            return fieldValue.asDouble() < Double.parseDouble(String.valueOf(expectedValue));
        } else if (fieldValue.isTextual()) {
            return fieldValue.asText().compareTo(String.valueOf(expectedValue)) < 0;
        }
        
        return false;
    }
    
    private boolean isLessThanOrEqual(JsonNode fieldValue, Object expectedValue) {
        return isLessThan(fieldValue, expectedValue) || isEqual(fieldValue, expectedValue);
    }
    
    private boolean containsText(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        String text = fieldValue.asText().toLowerCase();
        String searchText = String.valueOf(expectedValue).toLowerCase();
        
        return text.contains(searchText);
    }
    
    private boolean startsWithText(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        return fieldValue.asText().startsWith(String.valueOf(expectedValue));
    }
    
    private boolean endsWithText(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        return fieldValue.asText().endsWith(String.valueOf(expectedValue));
    }
    
    private boolean isInList(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        if (expectedValue instanceof List) {
            List<?> list = (List<?>) expectedValue;
            String fieldText = fieldValue.asText();
            
            return list.stream()
                .anyMatch(item -> String.valueOf(item).equals(fieldText));
        }
        
        return false;
    }
    
    private boolean matchesRegex(JsonNode fieldValue, Object expectedValue) {
        if (fieldValue == null || fieldValue.isNull()) return false;
        
        try {
            Pattern pattern = Pattern.compile(String.valueOf(expectedValue));
            return pattern.matcher(fieldValue.asText()).matches();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Compare two JSON nodes for sorting
     */
    private int compareNodes(JsonNode a, JsonNode b, String sortBy, String sortDirection) {
        if (sortBy == null || sortBy.isEmpty()) return 0;
        
        JsonNode valueA = getFieldValue(a, sortBy);
        JsonNode valueB = getFieldValue(b, sortBy);
        
        int result = 0;
        
        if (valueA == null && valueB == null) {
            result = 0;
        } else if (valueA == null) {
            result = -1;
        } else if (valueB == null) {
            result = 1;
        } else if (valueA.isNumber() && valueB.isNumber()) {
            result = Double.compare(valueA.asDouble(), valueB.asDouble());
        } else {
            result = valueA.asText().compareTo(valueB.asText());
        }
        
        return "DESC".equalsIgnoreCase(sortDirection) ? -result : result;
    }
    
    /**
     * Project only selected fields from JSON object
     */
    private JsonNode projectFields(JsonNode json, List<String> selectFields) {
        if (selectFields == null || selectFields.isEmpty()) {
            return json;
        }
        
        ObjectNode result = objectMapper.createObjectNode();
        
        for (String field : selectFields) {
            JsonNode value = getFieldValue(json, field);
            if (value != null) {
                // Handle nested field projection
                if (field.contains(".")) {
                    setNestedField(result, field, value);
                } else {
                    result.set(field, value);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Set nested field in result object
     */
    private void setNestedField(ObjectNode result, String fieldPath, JsonNode value) {
        String[] parts = fieldPath.split("\\.");
        ObjectNode current = result;
        
        for (int i = 0; i < parts.length - 1; i++) {
            String part = parts[i];
            JsonNode existing = current.get(part);
            
            if (existing == null || !existing.isObject()) {
                current.set(part, objectMapper.createObjectNode());
            }
            
            current = (ObjectNode) current.get(part);
        }
        
        current.set(parts[parts.length - 1], value);
    }
}

// 4. Service class
public class JsonQueryService {
    private final JsonQueryEngine queryEngine;
    private final ObjectMapper objectMapper;
    
    public JsonQueryService() {
        this.queryEngine = new JsonQueryEngine();
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * Execute query on JSON data
     */
    public String executeQuery(String jsonData, String queryJson) throws Exception {
        return queryEngine.executeQuery(jsonData, queryJson);
    }
    
    /**
     * Parse query from JSON string
     */
    public JsonQueryRequest parseQuery(String queryJson) throws Exception {
        return objectMapper.readValue(queryJson, JsonQueryRequest.class);
    }
    
    /**
     * Execute query with parsed objects
     */
    public List<JsonNode> executeQueryWithObjects(List<JsonNode> data, JsonQueryRequest request) {
        return queryEngine.executeQuery(data, request);
    }
}

// 5. Usage example
public class JsonQueryExample {
    public static void main(String[] args) {
        try {
            JsonQueryService service = new JsonQueryService();
            
            // Sample JSON data
            String jsonData = """
                [
                    {
                        "id": 1,
                        "name": "John Doe",
                        "age": 30,
                        "email": "john@example.com",
                        "department": "IT",
                        "salary": 75000,
                        "address": {
                            "city": "New York",
                            "country": "USA"
                        },
                        "skills": ["Java", "Python", "SQL"]
                    },
                    {
                        "id": 2,
                        "name": "Jane Smith",
                        "age": 25,
                        "email": "jane@example.com",
                        "department": "Marketing",
                        "salary": 65000,
                        "address": {
                            "city": "Los Angeles",
                            "country": "USA"
                        },
                        "skills": ["Marketing", "Analytics", "Design"]
                    },
                    {
                        "id": 3,
                        "name": "Bob Johnson",
                        "age": 35,
                        "email": "bob@example.com",
                        "department": "IT",
                        "salary": 85000,
                        "address": {
                            "city": "Chicago",
                            "country": "USA"
                        },
                        "skills": ["Java", "Docker", "Kubernetes"]
                    }
                ]
                """;
            
            // Query: Find IT employees older than 28, sorted by salary
            String query = """
                {
                    "conditions": [
                        {
                            "field": "department",
                            "operator": "eq",
                            "value": "IT",
                            "logicalOperator": "AND"
                        },
                        {
                            "field": "age",
                            "operator": "gt",
                            "value": 28
                        }
                    ],
                    "selectFields": ["id", "name", "age", "salary", "address.city"],
                    "sortBy": "salary",
                    "sortDirection": "DESC",
                    "limit": 10
                }
                """;
            
            String result = service.executeQuery(jsonData, query);
            System.out.println("Query Result:");
            System.out.println(result);
            
            // Example with text search
            String textSearchQuery = """
                {
                    "conditions": [
                        {
                            "field": "name",
                            "operator": "contains",
                            "value": "john"
                        }
                    ],
                    "selectFields": ["name", "email", "department"]
                }
                """;
            
            String textResult = service.executeQuery(jsonData, textSearchQuery);
            System.out.println("\nText Search Result:");
            System.out.println(textResult);
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}