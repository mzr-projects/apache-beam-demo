I'll help you create a query builder for Elasticsearch in a Spring Boot application that can fetch data from multiple documents and produce different outputs. Here's a comprehensive approach:
1. Setup Dependencies
First, add the necessary dependencies to your pom.xml:

 <dependencies>
    <!-- Spring Boot Starter Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Data Elasticsearch -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
    </dependency>
    
    <!-- Elasticsearch Rest High Level Client -->
    <dependency>
        <groupId>org.elasticsearch.client</groupId>
        <artifactId>elasticsearch-rest-high-level-client</artifactId>
    </dependency>
</dependencies>
 2. Configuration
Configure Elasticsearch connection in application.yml:

 spring:
  elasticsearch:
    rest:
      uris: http://localhost:9200
      username: elastic  # if authentication is enabled
      password: password # if authentication is enabled
 3. Create a Query Builder Pattern
Here's a flexible query builder implementation:
Base Query Builder Interface

 public interface QueryBuilder<T> {
    QueryBuilder<T> withIndex(String... indices);
    QueryBuilder<T> withField(String field, Object value);
    QueryBuilder<T> withRange(String field, Object from, Object to);
    QueryBuilder<T> withSort(String field, SortOrder order);
    QueryBuilder<T> withSize(int size);
    QueryBuilder<T> withFrom(int from);
    QueryBuilder<T> withAggregation(String name, AggregationBuilder aggregation);
    SearchRequest build();
    T execute();
}
 Implementation

 import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.aggregations.AggregationBuilder;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.sort.SortOrder;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
public class ElasticsearchQueryBuilder implements QueryBuilder<SearchResponse> {
    
    private final RestHighLevelClient client;
    private final List<String> indices = new ArrayList<>();
    private final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    private final SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    private final Map<String, AggregationBuilder> aggregations = new HashMap<>();
    
    public ElasticsearchQueryBuilder(RestHighLevelClient client) {
        this.client = client;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withIndex(String... indices) {
        this.indices.addAll(List.of(indices));
        return this;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withField(String field, Object value) {
        boolQuery.must(QueryBuilders.termQuery(field, value));
        return this;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withRange(String field, Object from, Object to) {
        boolQuery.must(QueryBuilders.rangeQuery(field).from(from).to(to));
        return this;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withSort(String field, SortOrder order) {
        sourceBuilder.sort(field, order);
        return this;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withSize(int size) {
        sourceBuilder.size(size);
        return this;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withFrom(int from) {
        sourceBuilder.from(from);
        return this;
    }
    
    @Override
    public QueryBuilder<SearchResponse> withAggregation(String name, AggregationBuilder aggregation) {
        aggregations.put(name, aggregation);
        return this;
    }
    
    @Override
    public SearchRequest build() {
        sourceBuilder.query(boolQuery);
        aggregations.forEach(sourceBuilder::aggregation);
        
        SearchRequest searchRequest = new SearchRequest();
        if (!indices.isEmpty()) {
            searchRequest.indices(indices.toArray(new String[0]));
        }
        searchRequest.source(sourceBuilder);
        
        return searchRequest;
    }
    
    @Override
    public SearchResponse execute() {
        try {
            return client.search(build(), RequestOptions.DEFAULT);
        } catch (IOException e) {
            throw new RuntimeException("Failed to execute search", e);
        }
    }
}
 4. Output Transformer Pattern
Create flexible output transformers for different client needs:
Base Transformer Interface

 public interface OutputTransformer<T> {
    T transform(SearchResponse response);
}
 Different Output Implementations

 // Simple DTO Output
@Component
public class SimpleDtoTransformer implements OutputTransformer<List<SimpleDto>> {
    
    @Override
    public List<SimpleDto> transform(SearchResponse response) {
        List<SimpleDto> results = new ArrayList<>();
        
        response.getHits().forEach(hit -> {
            Map<String, Object> source = hit.getSourceAsMap();
            SimpleDto dto = new SimpleDto();
            dto.setId(hit.getId());
            dto.setTitle((String) source.get("title"));
            dto.setDescription((String) source.get("description"));
            results.add(dto);
        });
        
        return results;
    }
}

// Aggregated Output
@Component
public class AggregatedOutputTransformer implements OutputTransformer<AggregatedResult> {
    
    @Override
    public AggregatedResult transform(SearchResponse response) {
        AggregatedResult result = new AggregatedResult();
        result.setTotalHits(response.getHits().getTotalHits().value);
        
        // Process aggregations
        if (response.getAggregations() != null) {
            // Handle different aggregation types
            response.getAggregations().forEach(agg -> {
                // Process based on aggregation type
                result.addAggregation(agg.getName(), processAggregation(agg));
            });
        }
        
        return result;
    }
    
    private Object processAggregation(Aggregation agg) {
        // Implement aggregation processing logic
        return null;
    }
}

// JSON Output
@Component
public class JsonOutputTransformer implements OutputTransformer<JsonNode> {
    
    private final ObjectMapper objectMapper;
    
    public JsonOutputTransformer(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }
    
    @Override
    public JsonNode transform(SearchResponse response) {
        ObjectNode result = objectMapper.createObjectNode();
        ArrayNode hits = objectMapper.createArrayNode();
        
        response.getHits().forEach(hit -> {
            ObjectNode hitNode = objectMapper.createObjectNode();
            hitNode.put("_id", hit.getId());
            hitNode.put("_index", hit.getIndex());
            hitNode.set("_source", objectMapper.valueToTree(hit.getSourceAsMap()));
            hits.add(hitNode);
        });
        
        result.set("hits", hits);
        result.put("total", response.getHits().getTotalHits().value);
        
        return result;
    }
}
 5. Service Layer Implementation
Create a service that combines the query builder with transformers:

 @Service
public class MultiDocumentSearchService {
    
    private final ElasticsearchQueryBuilder queryBuilder;
    private final Map<OutputType, OutputTransformer<?>> transformers;
    
    public MultiDocumentSearchService(
            ElasticsearchQueryBuilder queryBuilder,
            SimpleDtoTransformer simpleDtoTransformer,
            AggregatedOutputTransformer aggregatedTransformer,
            JsonOutputTransformer jsonTransformer) {
        
        this.queryBuilder = queryBuilder;
        this.transformers = Map.of(
            OutputType.SIMPLE, simpleDtoTransformer,
            OutputType.AGGREGATED, aggregatedTransformer,
            OutputType.JSON, jsonTransformer
        );
    }
    
    public <T> T searchMultipleDocuments(SearchCriteria criteria, OutputType outputType) {
        // Build query based on criteria
        QueryBuilder<SearchResponse> query = queryBuilder
            .withIndex(criteria.getIndices())
            .withSize(criteria.getSize())
            .withFrom(criteria.getFrom());
        
        // Add filters
        criteria.getFilters().forEach((field, value) -> 
            query.withField(field, value)
        );
        
        // Add range queries
        criteria.getRangeFilters().forEach(range -> 
            query.withRange(range.getField(), range.getFrom(), range.getTo())
        );
        
        // Execute search
        SearchResponse response = query.execute();
        
        // Transform output based on requested type
        OutputTransformer<T> transformer = (OutputTransformer<T>) transformers.get(outputType);
        return transformer.transform(response);
    }
}
 6. Controller Implementation

 @RestController
@RequestMapping("/api/search")
public class SearchController {
    
    private final MultiDocumentSearchService searchService;
    
    public SearchController(MultiDocumentSearchService searchService) {
        this.searchService = searchService;
    }
    
    @PostMapping("/multi-document")
    public ResponseEntity<?> searchMultipleDocuments(
            @RequestBody SearchRequest request,
            @RequestParam(defaultValue = "JSON") OutputType outputType) {
        
        SearchCriteria criteria = SearchCriteria.builder()
            .indices(request.getIndices())
            .filters(request.getFilters())
            .size(request.getSize())
            .from(request.getFrom())
            .build();
        
        Object result = searchService.searchMultipleDocuments(criteria, outputType);
        return ResponseEntity.ok(result);
    }
}
 7. Advanced Features
Fluent API for Complex Queries

 @Component
public class FluentQueryBuilder {
    
    private final ElasticsearchQueryBuilder queryBuilder;
    
    public FluentQueryBuilder(ElasticsearchQueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }
    
    public SearchResponse findDocumentsAcrossIndices(String... indices) {
        return queryBuilder
            .withIndex(indices)
            .withField("status", "active")
            .withRange("created_date", "2024-01-01", "2024-12-31")
            .withSort("created_date", SortOrder.DESC)
            .withSize(100)
            .execute();
    }
    
    public SearchResponse searchWithAggregations(String index) {
        return queryBuilder
            .withIndex(index)
            .withAggregation("category_count", 
                AggregationBuilders.terms("categories").field("category.keyword"))
            .withAggregation("price_stats", 
                AggregationBuilders.stats("price_statistics").field("price"))
            .execute();
    }
}
 Caching Support

 @Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("searchResults");
    }
}

@Service
public class CachedSearchService {
    
    @Cacheable(value = "searchResults", key = "#criteria.hashCode()")
    public <T> T searchWithCache(SearchCriteria criteria, OutputType outputType) {
        // Implementation
    }
}
 This architecture provides:
	1.	Flexibility: Easy to add new query types and output formats 	2.	Reusability: Query builder can be used across different services 	3.	Maintainability: Clear separation of concerns 	4.	Scalability: Can handle multiple indices and document types 	5.	Performance: Support for caching and efficient queries
You can extend this further by adding:
	•	Query validation 	•	Error handling and retry logic 	•	Async search support 	•	Scroll API for large result sets 	•	Security and access control 	•	Query logging and monitoring
