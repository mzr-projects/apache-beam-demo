import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class SirenJoinQuery {
    
    private String elasticsearchHost;
    private int elasticsearchPort;
    private CloseableHttpClient httpClient;
    private ObjectMapper mapper;
    
    public SirenJoinQuery(String host, int port) {
        this.elasticsearchHost = host;
        this.elasticsearchPort = port;
        this.httpClient = HttpClients.createDefault();
        this.mapper = new ObjectMapper();
    }
    
    /**
     * Create and execute a dynamic Siren join query
     */
    public String executeJoinQuery(
            String sourceIndex,
            String targetIndex,
            String joinField,
            String targetJoinField,
            Map<String, Object> filterCriteria) throws IOException {
        
        // Build the complete query JSON
        ObjectNode queryBody = buildJoinQueryJson(
            sourceIndex, targetIndex, joinField, 
            targetJoinField, filterCriteria
        );
        
        // Create the search endpoint URL
        String url = String.format("http://%s:%d/%s/_search", 
            elasticsearchHost, elasticsearchPort, sourceIndex);
        
        // Execute the POST request
        return executePost(url, queryBody.toString());
    }
    
    /**
     * Build the Siren join query JSON
     */
    private ObjectNode buildJoinQueryJson(
            String sourceIndex,
            String targetIndex,
            String joinField,
            String targetJoinField,
            Map<String, Object> filterCriteria) {
        
        ObjectNode root = mapper.createObjectNode();
        ObjectNode query = mapper.createObjectNode();
        ObjectNode join = mapper.createObjectNode();
        
        // Configure the join
        ArrayNode indices = mapper.createArrayNode();
        indices.add(sourceIndex);
        join.set("indices", indices);
        join.put("on", joinField);
        
        // Set the request details
        ObjectNode request = mapper.createObjectNode();
        request.put("index", targetIndex);
        request.put("path", targetJoinField);
        
        // Add filters dynamically if provided
        if (filterCriteria != null && !filterCriteria.isEmpty()) {
            ObjectNode filterQuery = buildDynamicQuery(filterCriteria);
            request.set("query", filterQuery);
        }
        
        join.set("request", request);
        query.set("join", join);
        root.set("query", query);
        
        return root;
    }
    
    /**
     * Create a complex join with filters on both source and target
     */
    public String executeComplexJoin(
            String sourceIndex,
            String targetIndex,
            String joinField,
            String targetJoinField,
            Map<String, Object> sourceFilters,
            Map<String, Object> targetFilters) throws IOException {
        
        ObjectNode root = mapper.createObjectNode();
        ObjectNode query = mapper.createObjectNode();
        ObjectNode bool = mapper.createObjectNode();
        ArrayNode must = mapper.createArrayNode();
        
        // Add source filters
        if (sourceFilters != null && !sourceFilters.isEmpty()) {
            ObjectNode sourceQuery = buildDynamicQuery(sourceFilters);
            must.add(sourceQuery);
        }
        
        // Add join query
        ObjectNode joinNode = mapper.createObjectNode();
        ObjectNode join = mapper.createObjectNode();
        
        ArrayNode indices = mapper.createArrayNode();
        indices.add(sourceIndex);
        join.set("indices", indices);
        join.put("on", joinField);
        
        ObjectNode request = mapper.createObjectNode();
        request.put("index", targetIndex);
        request.put("path", targetJoinField);
        
        if (targetFilters != null && !targetFilters.isEmpty()) {
            request.set("query", buildDynamicQuery(targetFilters));
        }
        
        join.set("request", request);
        joinNode.set("join", join);
        must.add(joinNode);
        
        bool.set("must", must);
        query.set("bool", bool);
        root.set("query", query);
        
        String url = String.format("http://%s:%d/%s/_search", 
            elasticsearchHost, elasticsearchPort, sourceIndex);
        
        return executePost(url, root.toString());
    }
    
    /**
     * Build dynamic query from filter criteria
     */
    private ObjectNode buildDynamicQuery(Map<String, Object> filterCriteria) {
        ObjectNode boolQuery = mapper.createObjectNode();
        ObjectNode bool = mapper.createObjectNode();
        ArrayNode must = mapper.createArrayNode();
        
        for (Map.Entry<String, Object> entry : filterCriteria.entrySet()) {
            ObjectNode termQuery = mapper.createObjectNode();
            ObjectNode term = mapper.createObjectNode();
            
            if (entry.getValue() instanceof String) {
                term.put(entry.getKey(), (String) entry.getValue());
            } else if (entry.getValue() instanceof Integer) {
                term.put(entry.getKey(), (Integer) entry.getValue());
            } else if (entry.getValue() instanceof Long) {
                term.put(entry.getKey(), (Long) entry.getValue());
            } else if (entry.getValue() instanceof Double) {
                term.put(entry.getKey(), (Double) entry.getValue());
            } else if (entry.getValue() instanceof Boolean) {
                term.put(entry.getKey(), (Boolean) entry.getValue());
            }
            
            termQuery.set("term", term);
            must.add(termQuery);
        }
        
        bool.set("must", must);
        boolQuery.set("bool", bool);
        
        return boolQuery;
    }
    
    /**
     * Execute HTTP POST request
     */
    private String executePost(String url, String jsonBody) throws IOException {
        HttpPost httpPost = new HttpPost(url);
        
        // Set headers
        httpPost.setHeader("Content-Type", "application/json");
        httpPost.setHeader("Accept", "application/json");
        
        // Set the JSON body
        StringEntity entity = new StringEntity(jsonBody, "UTF-8");
        httpPost.setEntity(entity);
        
        // Execute the request
        HttpResponse response = httpClient.execute(httpPost);
        
        // Get the response
        String responseBody = EntityUtils.toString(response.getEntity());
        
        // Check status code
        int statusCode = response.getStatusLine().getStatusCode();
        if (statusCode >= 200 && statusCode < 300) {
            return responseBody;
        } else {
            throw new IOException("HTTP error code: " + statusCode + ", Response: " + responseBody);
        }
    }
    
    /**
     * Add query size limit
     */
    public String executeJoinQueryWithSize(
            String sourceIndex,
            String targetIndex,
            String joinField,
            String targetJoinField,
            Map<String, Object> filterCriteria,
            int size) throws IOException {
        
        ObjectNode queryBody = buildJoinQueryJson(
            sourceIndex, targetIndex, joinField, 
            targetJoinField, filterCriteria
        );
        
        // Add size parameter
        queryBody.put("size", size);
        
        String url = String.format("http://%s:%d/%s/_search", 
            elasticsearchHost, elasticsearchPort, sourceIndex);
        
        return executePost(url, queryBody.toString());
    }
    
    /**
     * Build query with multiple joins (chained joins)
     */
    public String executeMultipleJoins(
            String sourceIndex,
            JoinConfig[] joins) throws IOException {
        
        ObjectNode root = mapper.createObjectNode();
        ObjectNode query = mapper.createObjectNode();
        ObjectNode bool = mapper.createObjectNode();
        ArrayNode must = mapper.createArrayNode();
        
        // Add each join to the must clause
        for (JoinConfig joinConfig : joins) {
            ObjectNode joinNode = mapper.createObjectNode();
            ObjectNode join = mapper.createObjectNode();
            
            ArrayNode indices = mapper.createArrayNode();
            indices.add(sourceIndex);
            join.set("indices", indices);
            join.put("on", joinConfig.getJoinField());
            
            ObjectNode request = mapper.createObjectNode();
            request.put("index", joinConfig.getTargetIndex());
            request.put("path", joinConfig.getTargetJoinField());
            
            if (joinConfig.getFilters() != null && !joinConfig.getFilters().isEmpty()) {
                request.set("query", buildDynamicQuery(joinConfig.getFilters()));
            }
            
            join.set("request", request);
            joinNode.set("join", join);
            must.add(joinNode);
        }
        
        bool.set("must", must);
        query.set("bool", bool);
        root.set("query", query);
        
        String url = String.format("http://%s:%d/%s/_search", 
            elasticsearchHost, elasticsearchPort, sourceIndex);
        
        return executePost(url, root.toString());
    }
    
    /**
     * Close the HTTP client
     */
    public void close() throws IOException {
        if (httpClient != null) {
            httpClient.close();
        }
    }
    
    /**
     * Helper class for join configuration
     */
    public static class JoinConfig {
        private String targetIndex;
        private String joinField;
        private String targetJoinField;
        private Map<String, Object> filters;
        
        public JoinConfig(String targetIndex, String joinField, 
                         String targetJoinField, Map<String, Object> filters) {
            this.targetIndex = targetIndex;
            this.joinField = joinField;
            this.targetJoinField = targetJoinField;
            this.filters = filters;
        }
        
        // Getters
        public String getTargetIndex() { return targetIndex; }
        public String getJoinField() { return joinField; }
        public String getTargetJoinField() { return targetJoinField; }
        public Map<String, Object> getFilters() { return filters; }
    }
    
    /**
     * Usage example
     */
    public static void main(String[] args) {
        SirenJoinQuery sirenQuery = new SirenJoinQuery("localhost", 9200);
        
        try {
            // Example 1: Simple join with filters
            Map<String, Object> filters = new HashMap<>();
            filters.put("status", "active");
            filters.put("age", 25);
            
            String result = sirenQuery.executeJoinQuery(
                "orders",           // source index
                "customers",        // target index
                "customer_id",      // join field in orders
                "id",              // join field in customers
                filters            // filters for customers
            );
            
            System.out.println("Simple Join Result:");
            System.out.println(result);
            
            // Example 2: Complex join with source and target filters
            Map<String, Object> sourceFilters = new HashMap<>();
            sourceFilters.put("order_status", "completed");
            
            Map<String, Object> targetFilters = new HashMap<>();
            targetFilters.put("customer_type", "premium");
            
            String complexResult = sirenQuery.executeComplexJoin(
                "orders",
                "customers",
                "customer_id",
                "id",
                sourceFilters,
                targetFilters
            );
            
            System.out.println("\nComplex Join Result:");
            System.out.println(complexResult);
            
            // Example 3: Join with size limit
            String limitedResult = sirenQuery.executeJoinQueryWithSize(
                "orders",
                "customers",
                "customer_id",
                "id",
                filters,
                10  // Return only 10 results
            );
            
            System.out.println("\nLimited Join Result:");
            System.out.println(limitedResult);
            
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                sirenQuery.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}