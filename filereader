import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ResourceAwareItemReaderItemStream;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;

@Component
public class SingleResourceItemReader implements ItemReader<Resource>, ResourceAwareItemReaderItemStream<Resource> {

    private Resource resource;
    private boolean hasRead = true;  // Start as true to handle edge cases

    @Override
    public Resource read() {
        if (hasRead || resource == null) {
            return null;
        }
        hasRead = true;
        return resource;
    }

    @Override
    public void setResource(Resource resource) {
        this.resource = resource;
        hasRead = false;  // Reset for the new resource
    }

    // ItemStream methods (minimal implementation; MultiResourceItemReader handles most state)
    @Override
    public void open(org.springframework.batch.item.ExecutionContext executionContext) {
        // No-op
    }

    @Override
    public void update(org.springframework.batch.item.ExecutionContext executionContext) {
        // No-op
    }

    @Override
    public void close() {
        // No-op
    }
}




import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.file.MultiResourceItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import java.io.IOException;
import java.util.Arrays;

@Configuration
public class BatchConfig {

    @Bean
    @StepScope  // Required for late binding of job parameters
    public MultiResourceItemReader<Resource> imageFileReader(
            @Value("#{jobParameters['input.directory']}") String inputDirectory,
            SingleResourceItemReader delegate) throws IOException {

        MultiResourceItemReader<Resource> reader = new MultiResourceItemReader<>();
        reader.setDelegate(delegate);

        // Resolve resources recursively
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        String pattern = "file:" + inputDirectory.replace("\\", "/") + "/**/*";  // All files recursively

        Resource[] allResources = resolver.getResources(pattern);

        // Optional: Filter by common image extensions (case-insensitive)
        Resource[] imageResources = Arrays.stream(allResources)
                .filter(r -> {
                    String filename = r.getFilename();
                    if (filename == null) return false;
                    String lower = filename.toLowerCase();
                    return lower.endsWith(".jpg") || lower.endsWith(".jpeg") ||
                           lower.endsWith(".png") || lower.endsWith(".gif") ||
                           lower.endsWith(".bmp") || lower.endsWith(".webp");
                })
                .sorted((r1, r2) -> r1.getFilename().compareTo(r2.getFilename()))  // Optional: sort alphabetically
                .toArray(Resource[]::new);

        reader.setResources(imageResources);
        reader.setSaveState(true);  // For restartability

        return reader;
    }

    // Other beans: ItemProcessor, ItemWriter, Step, Job...
}





import org.springframework.batch.item.ItemProcessor;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import org.springframework.core.io.Resource;

public class ImageProcessingProcessor implements ItemProcessor<Resource, ProcessedImage> {  // Replace ProcessedImage with your DTO

    @Override
    public ProcessedImage process(Resource resource) throws Exception {
        String filename = resource.getFilename();

        try (var inputStream = resource.getInputStream()) {
            BufferedImage image = ImageIO.read(inputStream);
            if (image == null) {
                // Not a readable image format; skip
                System.out.println("Skipping non-image file: " + filename);
                return null;
            }

            // Process the image here (e.g., resize, analyze, etc.)
            // Example: just wrap it
            return new ProcessedImage(filename, image);
        }
    }
}